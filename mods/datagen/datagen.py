# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AIINF
                                 A QGIS plugin
 Modelos de inteligência artificial no Qgis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-08-14
        git sha              : $Format:%H$
        copyright            : Mateus Melo Siqueira/Remis Balaniuk

 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
import os
import sys 
sys.path.append(os.path.join(os.path.dirname(__file__),'lib'))

from .datagen_dialog import DATAGENDialog

from PIL import Image
Image.MAX_IMAGE_PIXELS = 10000000000
from qgis.core import QgsWkbTypes, QgsGeometry, QgsPoint, QgsProject, QgsMapLayerProxyModel
from qgis.core import *
from qgis.gui import *
from qgis.utils import *
from qgis.PyQt.QtWidgets import QMessageBox,QWidget, QAction, QFileDialog, QTableWidget, QTableWidgetItem, QGridLayout, QDialog, QPushButton, QProgressBar
from PyQt5.QtCore import QThread, pyqtSignal
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication
from qgis.PyQt.QtWidgets import QToolButton, QMenu, QLineEdit, QLabel, QDialog, QPushButton, QCheckBox, QGridLayout
from qgis.PyQt.QtCore import QObject, Qt, QSize
from qgis.PyQt.QtGui import QIcon
from qgis.PyQt.QtWidgets import QAction
from qgis.core import QgsWkbTypes, QgsGeometry, QgsPoint, QgsProject, QgsMapLayerProxyModel
from qgis.gui import QgsRubberBand, QgsMapLayerComboBox, QgsFieldComboBox
from PyQt5.QtWidgets import QTabWidget, QFrame,QAbstractItemView,  QMessageBox, QShortcut, QDockWidget, QComboBox, QLineEdit, QTableWidget, QTableWidgetItem, QCheckBox, QGridLayout, QLabel, QWidget, QSizePolicy,QSpacerItem, QPushButton
from qgis.PyQt.QtCore import Qt, QSize
from qgis.PyQt.QtGui import QColor, QCursor, QPixmap, QIcon, QImage
from PyQt5.QtCore import QThread, pyqtSignal
import processing
from qgis.core import QgsVectorLayer
from qgis.core import QgsVectorLayer,QgsRasterLayer, QgsRectangle, QgsVectorFileWriter, QgsGeometry,QgsFields, QgsField, QgsFeature, QgsProject
from qgis.PyQt.QtCore import QVariant
import processing
from qgis.core import *
from qgis.gui import *
from osgeo import gdal
from qgis.core import QgsProcessingFeatureSourceDefinition
from qgis.core import QgsProject, QgsVectorLayer, QgsRasterLayer, QgsCoordinateTransform, QgsCoordinateReferenceSystem, QgsFeatureRequest
from qgis.analysis import QgsRasterCalculatorEntry, QgsRasterCalculator
import random
import shutil
class WorkerInference(QThread):
    def __init__(self, plugin_dir,cls_main):
        QThread.__init__(self)
        self.stp = False
        self.plugin_dir = plugin_dir
        self.datagen = cls_main


    up_list = pyqtSignal(list)
    results = pyqtSignal(list)

    def run(self):
        print("worker running!")
        self.gerar_tiles()
        self.apagar_tiles()
        self.exportar_datagen()

    def gerar_tiles(self):

        # Nome da camada raster virtual
        raster_layer_name = self.datagen.dlg.map_combo_rvt.currentText()

        # Obtém a camada raster
        raster_layer = QgsProject.instance().mapLayersByName(raster_layer_name)[0]

        #cálculo do poligono

        pixelSizeX = raster_layer.rasterUnitsPerPixelX()
        pixelSizeY = raster_layer.rasterUnitsPerPixelY()
        #print(pixelSizeX)
        gsd = pixelSizeX
        size = gsd * 1280
        # Tamanho dos polígonos (em pixels)
        polygon_size = int(size)

        # Nome da camada de saída
        output_layer_name = "poligonos_1280x1280"


        # Obtém o CRS da camada raster
        crs = raster_layer.crs()

        # Obtém a extensão do raster
        extent = raster_layer.extent()

        # Cria uma nova camada vetorial com o CRS da camada raster
        output_layer = QgsVectorLayer(f"Polygon?crs={crs.authid()}", output_layer_name, "memory")
        provider = output_layer.dataProvider()
        fields = provider.fields()
        fields.append(QgsField("id", QVariant.Int))
        provider.addAttributes(fields)
        output_layer.updateFields()

        # Cria uma geometria de polígono e adiciona à camada
        features = []
        x_min, y_min, x_max, y_max = extent.xMinimum(), extent.yMinimum(), extent.xMaximum(), extent.yMaximum()
        for x in range(int(x_min), int(x_max), polygon_size):
            for y in range(int(y_min), int(y_max), polygon_size):
                feat = QgsFeature()
                geom = QgsGeometry.fromRect(QgsRectangle(x, y, x + polygon_size, y + polygon_size))
                feat.setGeometry(geom)
                feat.setAttributes([len(features)])
                features.append(feat)

        provider.addFeatures(features)

        # Adiciona a camada ao mapa
        QgsProject.instance().addMapLayer(output_layer)

    def apagar_tiles(self):
        # Carregar as camadas
        nm2 = self.datagen.dlg.map_combo_amostras.currentText()
        nm1 = "poligonos_1280x1280"
        layer1 = QgsProject.instance().mapLayersByName(nm1)[0]
        layer2 = QgsProject.instance().mapLayersByName(nm2)[0]

        # Começar uma edição na camada 1
        layer1.startEditing()

        # Lista para armazenar IDs das features a serem deletadas
        features_to_delete = []

        # Iterar sobre os polígonos da primeira camada e verificar a contenção
        for feature1 in layer1.getFeatures():
            geom1 = feature1.geometry()
            is_contained = False
            for feature2 in layer2.getFeatures():
                geom2 = feature2.geometry()
                if geom1.contains(geom2):  # Verifica se geom1 está contido em geom2
                    is_contained = True
                    break
            if not is_contained:
                features_to_delete.append(feature1.id())

        # Deletar as features
        layer1.deleteFeatures(features_to_delete)
        #print(features_to_delete)
        # Salvar as edições
        layer1.commitChanges()

    # Função para criar o arquivo de rótulo no formato YOLOv5
    def create_yolo_label(self,classe_id,xmin_,ymin_,image_width, image_height, x_min, y_min, x_max, y_max):
        # Calcula as coordenadas do centro e a largura e altura
        #print(image_width, image_height, x_min, y_min, x_max, y_max)
        xmin_l = x_min - xmin_
        ymin_l = y_min - ymin_
        xmax_l = x_max - xmin_
        ymax_l = y_max - ymin_#

        x_center = (xmin_l + xmax_l) / (2 * image_width)
        y_center = (ymin_l + ymax_l) / (2 * image_height)
        width = (x_max - x_min) / image_width
        height = (y_max - y_min) / image_height

        """
        x_center = (x_min + x_max) / (2*image_width)
        y_center = (y_min + y_max) / (2*image_height)
        width = (x_max - x_min) / image_width
        height = (y_max - y_min) / image_height
        """
        """
        # Calcula as coordenadas normalizadas
        x_center /= image_width
        y_center /= image_height
        width /= image_width
        height /= image_height
        """
        # Cria a linha do rótulo (assumindo classe 0)
        label_line = f"{int(classe_id)-1} {x_center} {y_center} {width} {height}"
        return label_line


    def exportar_datagen(self):


        # Configurações personalizáveis
        output_dir = os.path.join(self.datagen.savedirname)  # Substitua pelo seu diretório de saída
        raster_band = 1  # Banda do raster a ser usada

        nm1 = 'poligonos_1280x1280'
        nm2 = self.datagen.dlg.map_combo_amostras.currentText()
        nm3 = self.datagen.dlg.map_combo_rvt.currentText()
        # Carregar as camadas
        extensoes_layer = QgsProject.instance().mapLayersByName(nm1)[0]
        amostras_layer = QgsProject.instance().mapLayersByName(nm2)[0]
        raster_virtual = QgsProject.instance().mapLayersByName(nm3)[0]


        # Iterar sobre as extensões
        for feature in extensoes_layer.getFeatures():
            extensoes_layer.removeSelection()
            geom = feature.geometry()
            extent = geom.boundingBox()
            xmin_ = extent.xMinimum()
            ymin_ = extent.yMinimum()
            xmax_ = extent.xMaximum()
            ymax_ = extent.yMaximum()

            #print("extent ",f"xmin: {xmin_}, ymin: {ymin_}, xmax: {xmax_}, ymax: {ymax_}")
            #print("extent",extent)
            extensoes_layer.select(feature.id())

            caminho_do_diretorio = os.path.join(output_dir,"images")
            if os.path.exists(caminho_do_diretorio):
                pass
            else:
                os.makedirs(caminho_do_diretorio)

            # Cortar o raster
            processing.run("gdal:cliprasterbymasklayer", {
                'INPUT': raster_virtual,
                'MASK': QgsProcessingFeatureSourceDefinition(extensoes_layer.id(), True),
                'OUTPUT': f"{caminho_do_diretorio}/image_{feature.id()}.tif",
                'BAND': raster_band,
                'CROP_TO_EXTENT': True,
                'NO_DATA': None,
                'ALPHA_BAND': False,
                'CROP_TO_CUTLINE': True
            })
            img = Image.open(f"{caminho_do_diretorio}/image_{feature.id()}.tif")
            name = f"{caminho_do_diretorio}/image_{feature.id()}.tif".replace(".tif",".jpeg")
            img.save(name)
            os.remove(f"{caminho_do_diretorio}/image_{feature.id()}.tif")


            #print(f"{caminho_do_diretorio}/image_{feature.id()}.tif")

            caminho_do_diretorio2 = os.path.join(output_dir, "labels")
            if os.path.exists(caminho_do_diretorio2):
                pass
            else:
                os.makedirs(caminho_do_diretorio2)

            # Criar o arquivo de rótulos
            with open(f"{caminho_do_diretorio2}/image_{feature.id()}.txt", 'w') as f:
                for amostra_feature in amostras_layer.getFeatures():
                    amostra_geom = amostra_feature.geometry()
                    if amostra_geom.intersects(geom):
                        """
                        # Calcular as coordenadas da amostra na imagem cortada
                        intersection = amostra_geom.intersection(geom)
                        xmin, ymin, xmax, ymax = intersection.boundingBox().toRectF().getCoords()
                        #print(xmin,ymin,xmax,ymax)
                        classe_id = amostra_feature['classe_id']
                        # Criar o rótulo
                        label_line = self.create_yolo_label(classe_id,xmin_,ymin_,extent.width(), extent.height(), xmin, ymin, xmax, ymax)
                        f.write(label_line + '\n')
                        """
                        #transform_context = QgsCoordinateTransformContext()
                        coord_transform = QgsCoordinateTransform(
                            amostras_layer.crs(),
                            extensoes_layer.crs(),
                            QgsProject.instance()
                        )

                        amostra_geom.transform(coord_transform)
                        x_center, y_center = amostra_geom.centroid().asPoint().x(), amostra_geom.centroid().asPoint().y()
                        #print(extent.xMinimum(),extent.yMinimum(),extent.xMaximum(),extent.yMaximum())
                        # Calcular as coordenadas relativas na imagem
                        x_center_norm = (x_center - extent.xMinimum()) / extent.width()
                        y_center_norm = -1*(y_center - extent.yMaximum()) / extent.height()


                        bbox_width = amostra_geom.boundingBox().width() / extent.width()
                        bbox_height = amostra_geom.boundingBox().height() / extent.height()


                        if not (x_center_norm<0 or y_center_norm<0) :
                            if not (x_center_norm>1 or y_center_norm>1):
                                # ID da classe (assumimos 0)
                                class_id = 0
                                f.write(f"{class_id} {x_center_norm} {y_center_norm} {bbox_width} {bbox_height}\n")

        # Cria os diretórios de destino se não existirem
        for subset in ['train', 'val']:
            for subdir in ['images', 'labels']:
                os.makedirs(os.path.join(output_dir, subset, subdir), exist_ok=True)

        image_files = [f for f in os.listdir(os.path.join(output_dir, 'images')) if f.endswith('.jpeg')]  # Adapte a extensão conforme necessário
        print(image_files)
        tamanho = len(image_files)
        indice_divisao = int(tamanho * 0.80)

        train = image_files[:indice_divisao]
        val = image_files[indice_divisao:]

        for img in train:
            print(os.path.join(output_dir,"images",img), os.path.join(output_dir,"train","images",img))
            os.rename(os.path.join(output_dir,"images",img), os.path.join(output_dir,"train","images",img))
            os.rename(os.path.join(output_dir, "labels", img.replace(".jpeg",".txt")), os.path.join(output_dir, "train", "labels", img.replace(".jpeg",".txt")))

        for img in val:
            os.rename(os.path.join(output_dir,"images",img), os.path.join(output_dir,"val","images",img))
            os.rename(os.path.join(output_dir, "labels", img.replace(".jpeg",".txt")), os.path.join(output_dir, "val", "labels", img.replace(".jpeg",".txt")))

        diretorio_para_remover = os.path.join(output_dir,"images")

        try:
            shutil.rmtree(diretorio_para_remover)
            print(f"O diretório {diretorio_para_remover} foi removido com sucesso.")
        except OSError as e:
            print(f"Erro ao remover o diretório: {e}")

        diretorio_para_remover = os.path.join(output_dir, "labels")

        try:
            shutil.rmtree(diretorio_para_remover)
            print(f"O diretório {diretorio_para_remover} foi removido com sucesso.")
        except OSError as e:
            print(f"Erro ao remover o diretório: {e}")

        #split dataset
        #source_directory = output_dir  # Substitua pelo caminho da sua pasta fonte
        #target_directory = output_dir  # Substitua pelo caminho da sua pasta de destino
        #self.split_data(source_directory, target_directory)
    def split_data(self,source_dir, target_dir, split_ratio=0.8):
        """
        Divide os arquivos em dois conjuntos (train e val) com a proporção especificada.

        Args:
            source_dir: Diretório raiz dos dados.
            target_dir: Diretório de destino para os conjuntos divididos.
            split_ratio: Proporção de dados para o conjunto de treinamento.
        """

        # Cria os diretórios de destino se não existirem
        for subset in ['train', 'val']:
            for subdir in ['images', 'labels']:
                os.makedirs(os.path.join(target_dir, subset, subdir), exist_ok=True)

        # Obtém a lista de arquivos de imagem (assumindo que os nomes são consistentes)
        image_files = [f for f in os.listdir(os.path.join(source_dir, 'images')) if
                       f.endswith('.jpg')]  # Adapte a extensão conforme necessário

        # Embaralha a lista de arquivos
        random.shuffle(image_files)

        # Calcula o índice de divisão
        split_index = int(len(image_files) * split_ratio)

        # Cria os conjuntos de treino e validação
        for i, file in enumerate(image_files):
            subset = 'train' if i < split_index else 'val'
            source_image = os.path.join(source_dir, 'images', file)
            source_label = os.path.join(source_dir, 'labels',
                                        file.replace('.jpg', '.txt'))  # Adapte a extensão conforme necessário
            target_image = os.path.join(target_dir, subset, 'images', file)
            target_label = os.path.join(target_dir, subset, 'labels', file.replace('.jpg', '.txt'))
            os.rename(source_image, target_image)
            os.rename(source_label, target_label)
class DATAGEN:
    def __init__(self, iface, cls_main):

        # Save reference to the QGIS interface
        self.gctools = cls_main
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = self.gctools.plugin_dir
        self.db = None
        self.savedirname = ''
        

    def setworker(self):

        self.worker_inferencer = WorkerInference(self.plugin_dir,self)
        self.worker_inferencer.run()



    def CloseEvent(self, event):
        print("closed")


    def saveproject(self):
        file = str(QFileDialog.getExistingDirectory())
        if file:
            self.savedirname = file
            self.dlg.line_saida.setText(self.savedirname)
    def run(self):
        self.dlg = DATAGENDialog()
        self.dlg.pb_gerar.pressed.connect(self.setworker)
        self.dlg.pb_saida.pressed.connect(self.saveproject)
        # show the dialog
        self.dlg.show()


        self.dlg.closeEvent = self.CloseEvent
