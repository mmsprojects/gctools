# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AIINF
                                 A QGIS plugin
 Modelos de inteligência artificial no Qgis
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2025-08-14
        git sha              : $Format:%H$
        copyright            : Mateus Melo Siqueira/Remis Balaniuk

 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""##
import os
import sys 
sys.path.append(os.path.join(os.path.dirname(__file__),'lib'))
from qgis.PyQt.QtCore import QSettings, QTranslator, QCoreApplication, QVariant, QTimer
from qgis.PyQt.QtGui import QIcon, QColor, QPixmap
from qgis.PyQt.QtWidgets import QMessageBox,QWidget, QAction, QFileDialog, QTableWidget, QTableWidgetItem, QGridLayout, QDialog, QPushButton, QProgressBar
#from PyQt5.QtCore import QVariant
from qgis.core import QgsVectorLayer,QgsRasterLayer, QgsRectangle, QgsVectorFileWriter, QgsGeometry,QgsFields, QgsField, QgsFeature, QgsProject
from qgis.PyQt.QtCore import QVariant
# Initialize Qt resources from file resources.py
#from .resources import *
# Import the code for the dialog#
from .ai_inf_dialog import AIINFDialog
from qgis.core import QgsExpressionContextUtils, QgsProject
from qgis.core import QgsVectorFileWriter
from datetime import datetime
import os.path
#from yolov5 import YOLOv5


#from sahi.model import Yolov5DetectionModel
from sahi import AutoDetectionModel
from sahi.utils.cv import read_image, visualize_object_predictions
from sahi.utils.file import download_from_url
from sahi.predict import get_prediction, get_sliced_prediction, predict

from PIL import Image
Image.MAX_IMAGE_PIXELS = 10000000000
#import yolov5
from osgeo import gdal
# import gdal
from qgis.core import *
from qgis.gui import *
from qgis.utils import *
from osgeo import osr
from PyQt5.QtCore import QThread, pyqtSignal
import sqlite3
import pathlib
from pathlib import Path
pathlib.PosixPath = pathlib.WindowsPath
# import osr
import multiprocessing

class WorkerInference(QThread):
    def __init__(self, plugin_dir, weight, file_folder_status, img_dir, images, img_size, is_slice, confidence, overlap, is_pontos, is_poligonos, db, proc_id, status):
        QThread.__init__(self)
        self.stp = False
        self.plugin_dir = plugin_dir
        self.file_folder_status = file_folder_status
        self.img_dir = img_dir
        self.images = images
        self.img_size = img_size
        self.is_slice = is_slice
        self.confidence = confidence
        self.overlap = overlap
        self.weight = weight
        self.is_pontos = is_pontos
        self.is_poligonos = is_poligonos
        self.db = db
        self.proc_id = proc_id
        self.status_list = status



    up_list = pyqtSignal(list)
    results = pyqtSignal(list)

    def updatesqlitedata(self,id_proces,process,image,total):
        data_hora_atual = datetime.now()

        self.c.execute('PRAGMA journal_mode=wal')
        self.c.execute(f"""UPDATE data_proc
                             SET date = '{data_hora_atual}',
                             status = 'FINISHED',
                             process = '{process}'
                             WHERE proc_id = {id_proces}
                             AND image = '{image}'
                            """)
        #.c.execute(f"""UPDATE procs
        #                 SET process = {total}
        #                 wHERE id = {id_proces}""")

        self.conn.commit()



    def run(self):
        self.inference()

    def inference(self):
        print("ok")
        if not self.stp:
            self.conn = sqlite3.connect(self.db)
            self.c = self.conn.cursor()

            self.device = 'cuda:0'#"cpu"  # or "cpu"
            #self.weight = None


            # detection_model = Yolov5DetectionModel(
            # model_path=self.weight,
            # prediction_score_threshold=float(self.dlg.cb_confidence.currentText()),
            # device="cpu",  # or 'cuda'
            # )
            detection_model = AutoDetectionModel.from_pretrained(
                model_type='yolov5',
                model_path=self.weight,
                confidence_threshold=float(self.confidence),
                device=self.device,  # or 'cuda:0'
            )



            #PROCESSAR DIRETÓRIO###########################################################
            #elif (self.file_folder_status == 0):
            #images = [os.path.basename(x) for x in os.listdir(self.img_dir)]

            process = []
            total = len(self.images)
            for i,img in enumerate(self.images):
                print(os.path.join(self.img_dir[i], img))

                image = read_image(os.path.join(self.img_dir[i], img))
                print("pre slice")
                result = get_sliced_prediction(
                    image,
                    detection_model,
                    slice_height=self.img_size,
                    slice_width=self.img_size,
                    overlap_height_ratio=float(self.overlap),
                    overlap_width_ratio=float(self.overlap)
                )

                #object_prediction_list = result["object_prediction_list"]
                object_prediction_list = result.object_prediction_list


                for pred in object_prediction_list:

                    pred_coco = pred.to_coco_prediction().json
                    box = pred_coco['bbox']
                    classe = pred_coco['category_name']
                    classe_id = pred_coco['category_id']
                    score = round(pred.score.value, 2)

                    xmin = box[0]
                    ymin = box[1]
                    xmax = xmin + box[2]
                    ymax = ymin + box[3]
                    x1, y1 = self.pixel2coord(os.path.join(self.img_dir[i], img), xmin, ymin)
                    x2, y2 = self.pixel2coord(os.path.join(self.img_dir[i], img), xmax, ymin)
                    x3, y3 = self.pixel2coord(os.path.join(self.img_dir[i], img), xmax, ymax)
                    x4, y4 = self.pixel2coord(os.path.join(self.img_dir[i], img), xmin, ymax)
                    # print(self.pixel2coord(self.img_dir,0,0))

                    res = {'x1': x1,
                           'y1': y1,
                           'x2': x2,
                           'y2': y2,
                           'x3': x3,
                           'y3': y3,
                           'x4': x4,
                           'y4': y4,
                           'id':i,
                           'classe':classe,
                           'classe_id':classe_id,
                           'score': score}

                    self.results.emit([res])


                    # print(geom)
                #print(i+1)
                #print([int(100*(i+1)/total)])

                self.up_list.emit([self.proc_id,int(100*(i+1)/total)])
                self.updatesqlitedata(self.proc_id,int(100),img,int(100*(i+1)/total))


            self.c.close()
            self.conn.close()
    def pixel2coord(self, raster_path, x, y):
        raster = gdal.Open(raster_path,gdal.GA_ReadOnly)
        xoff, a, b, yoff, d, e = raster.GetGeoTransform()
        xp = a * x + b * y + a * 0.5 + b * 0.5 + xoff
        yp = d * x + e * y + d * 0.5 + e * 0.5 + yoff
        return xp, yp

    # def boxes2QgsPolygons(self,boxes):

    # def boxes2QgsPoints(self,boxes):

class AIINF:
    def __init__(self, iface, cls_main):

        # Save reference to the QGIS interface
        self.gctools = cls_main
        self.iface = iface
        # initialize plugin directory
        self.plugin_dir = self.gctools.plugin_dir
        self.db = None
        
    def updateBar(self,data):
        #print(data[1])
        self.dlg.gcbar_geral.value = int(data[1])
        conn = sqlite3.connect(self.db)
        c = conn.cursor()
        c.row_factory = sqlite3.Row
        c.execute(f"""UPDATE procs
                     SET process = {data[1]}
                    WHERE id = {data[0]}""")
        conn.commit()

        #QgsExpressionContextUtils.setGlobalVariable( 'aigis_status',50)
    def setworker(self):

        self.create_results_layers()
        #get images
        images = []
        dirs = []
        status = []
        #process = []
        for row in range(0, self.dlg.table.rowCount()):
            images.append(self.dlg.table.item(row, 2).text())
            img_dir = self.dlg.table.item(row, 1).text()
            dirs.append(img_dir)
            status.append(self.dlg.table.item(row, 3).text())
            #process.append(self.dlg.table.item(row, 4).text())



        #get model_path
        self.model_path = os.path.join(self.plugin_dir, 'mods', 'ai_inf', 'weights')
        print(self.model_path)

        #get weight
        #weight = self.getmodel()
        weight = self.dlg.line_modelo.displayText()

        #get img_size
        #img_size = self.getsize()
        img_size = 1280


        #is sliced
        #if self.dlg.cb_slice_imagem.isChecked():
        is_slice = 1
        #else:
            #is_slice = 0

        #get pontos
        #if self.dlg.cb_pontos.isChecked():
        is_pontos = 1
        #else:
            #is_pontos = 0

        #get poligonos
        #if self.dlg.cb_poligonos.isChecked():
        is_poligonos = 1
        #else:
            #is_poligonos = 0

        #get confidence
        confidence = float(self.dlg.cb_confidence.currentText())

        #get overlap
        overlap = float(self.dlg.cb_overlap.currentText())

        self.savesqliteproc()
        self.insertsqlitedata(self.id_proc)

        #set Worker Thread
        self.worker_inferencer = WorkerInference(self.plugin_dir,
                                                 weight,
                                                 self.file_folder_status,
                                                 dirs,
                                                 images,
                                                 img_size,
                                                 is_slice,
                                                 confidence,
                                                 overlap,
                                                 is_pontos,
                                                 is_poligonos,
                                                 self.db,
                                                 self.id_proc,
                                                 status )

        self.worker_inferencer.up_list.connect(self.updateBar)
        self.worker_inferencer.results.connect(self.addfeature2layer)
        self.worker_inferencer.run()


    def getsize(self):
        if (self.dlg.cb_size == '1280'):
            # results = self.yolov5.predict(self.img_dir, size=1280)
            self.img_size = 1280
        elif (self.dlg.cb_size == '640'):
            # results = self.yolov5.predict(self.img_dir, size=640)
            self.img_size = 1280
        else:
            # results = self.yolov5.predict(self.img_dir, size=640)
            self.img_size = 640

        return self.img_size

    def getmodel(self):
        # init yolov5 model
        if (self.dlg.cb_tipo.currentText() == 'Classes Gerais (COCO Dataset)'):
            self.weight = os.path.join(self.model_path, 'yolov5x6.pt')
        elif (self.dlg.cb_tipo.currentText() == 'Arvores_10cm'):
            self.weight = os.path.join(self.model_path, 'arvores_mms_2024_v3.pt')
        elif (self.dlg.cb_tipo.currentText() == 'Arvores_1m'):
            self.weight = os.path.join(self.model_path, 'arvores_mms_v2.pt')
        elif (self.dlg.cb_tipo.currentText() == 'Lixao_24cm'):
            self.weight = os.path.join(self.model_path, 'novo_lixao_2024_v3.pt')
        else:
            self.weight = None

        return self.weight

    def dir_file(self):
        self.file_folder_status = 1
        self.img_dir = QFileDialog.getOpenFileName()[0]
        self.dlg.line_file.setText(self.img_dir)
        print(self.img_dir)

    def dir_folder(self):
        self.file_folder_status = 0
        #self.img_dir = QFileDialog.getExistingDirectory()

        filenames, _ = QFileDialog.getOpenFileNames(
                                                    None,
                                                    "QFileDialog.getOpenFileNames()",
                                                    "",
                                                    "Tiff (*.tif);;All Files (*);",)
        if filenames:
            self.img_dir = os.path.dirname(filenames[0])
            self.dlg.line_file.setText(self.img_dir)
            #fill table
            images = [os.path.basename(x) for x in filenames]
            #dirs = [os.path.dirname(x) for x in filenames]
            self.dlg.show()
            for x,im in enumerate(images):
                row = self.dlg.table.rowCount()

                color_pend = QColor()
                color_pend.setRgb(89, 141, 214)
                icon_pend = QIcon()
                icon_pend.addPixmap(QPixmap(os.path.join(self.plugin_dir, "icons", "pend.png")), QIcon.Normal, QIcon.Off)

                item_id = QTableWidgetItem()
                item_id.setCheckState(2)
                item_id.setText(str(x))

                item_img_dir = QTableWidgetItem()
                item_img_dir.setText(str(self.img_dir))

                item_img = QTableWidgetItem()
                item_img.setText(str(im))

                item_proc = QTableWidgetItem()
                item_proc.setText(str("PEND"))
                item_proc.setBackground(color_pend)
                item_proc.setIcon(icon_pend)


                self.dlg.table.insertRow(row)
                self.dlg.table.setItem(row, 0, item_id) #id
                self.dlg.table.setItem(row, 1, item_img_dir) #pasta
                self.dlg.table.setItem(row, 2, item_img) #imagem
                self.dlg.table.setItem(row, 3, item_proc) #status

            raster = gdal.Open(os.path.join(self.img_dir, images[0]),gdal.GA_ReadOnly)
            proj = osr.SpatialReference(wkt=raster.GetProjection())
            self.epsg = int(proj.GetAttrValue('AUTHORITY', 1))
            self.dlg.ln_srid.setText(str(self.epsg))


    def create_results_layers(self):
        self.srid = int(self.dlg.ln_srid.displayText())

        if self.dlg.cb_memory.isChecked():
            self.polygon = QgsVectorLayer('Polygon?crs=epsg:{}&index=yes'.format(self.epsg), 'poligonos_a',
                                          "memory")
            self.point = QgsVectorLayer('Point?crs=epsg:{}&index=yes'.format(self.epsg), 'pontos_p',
                                        "memory")
            self.pr = self.polygon.dataProvider()
            self.pr.addAttributes([QgsField("id", QVariant.Int), QgsField("classe", QVariant.String),
                                   QgsField("classe_id", QVariant.Int),
                                   QgsField("score", QVariant.Double)])
            self.pr_p = self.point.dataProvider()
            self.pr_p.addAttributes([QgsField("id", QVariant.Int), QgsField("classe", QVariant.String),
                                     QgsField("classe_id", QVariant.Int),
                                     QgsField("score", QVariant.Double)])

            QgsProject.instance().addMapLayers([self.point])
            #if (self.dlg.cb_poligonos.isChecked()):
            QgsProject.instance().addMapLayers([self.polygon])
        else:
            output = self.dlg.ln_output.displayText()
            dir = os.path.dirname(output)
            name = os.path.basename(output).replace(".shp","")
            out_a = os.path.join(dir,name+"_a.shp")
            out_p = os.path.join(dir,name+"_p.shp")
            polygon = QgsVectorLayer('Polygon?crs=epsg:{}&index=yes'.format(self.epsg), name+"_a",
                                          "memory")
            point = QgsVectorLayer('Point?crs=epsg:{}&index=yes'.format(self.epsg), name+"_p",
                                        "memory")


            options = QgsVectorFileWriter.SaveVectorOptions()
            options.driverName = 'ESRI Shapefile'
            context = QgsProject.instance().transformContext()
            # since QGIS 3.20 you should use writeAsVectorFormatV3
            QgsVectorFileWriter.writeAsVectorFormatV3(polygon, out_a, context, options)
            QgsVectorFileWriter.writeAsVectorFormatV3(point, out_p, context, options)

            self.polygon = QgsVectorLayer(out_a, name+"_a", "ogr")
            self.point = QgsVectorLayer(out_p, name+"_p", "ogr")

            self.pr = self.polygon.dataProvider()
            self.pr.addAttributes([QgsField("id", QVariant.Int), QgsField("classe", QVariant.String),
                                   QgsField("classe_id", QVariant.Int),
                                   QgsField("score", QVariant.Double)])

            self.pr_p = self.point.dataProvider()
            self.pr_p.addAttributes([QgsField("id", QVariant.Int), QgsField("classe", QVariant.String),
                                     QgsField("classe_id", QVariant.Int),
                                     QgsField("score", QVariant.Double)])
            QgsProject.instance().addMapLayers([self.point])
            #if (self.dlg.cb_poligonos.isChecked()):
            QgsProject.instance().addMapLayers([self.polygon])

    def addfeature2layer(self, data):
        fields = self.polygon.fields()

        feat = QgsFeature()
        feat.setFields(fields)
        feat_p = QgsFeature()
        feat_p.setFields(fields)

        x1 = data[0]['x1']
        y1 = data[0]['y1']
        x2 = data[0]['x2']
        y2 = data[0]['y2']
        x3 = data[0]['x3']
        y3 = data[0]['y3']
        x4 = data[0]['x4']
        y4 = data[0]['y4']

        i = data[0]['id']
        classe = data[0]['classe']
        classe_id = data[0]['classe_id']
        score = data[0]['score']


        geom = QgsGeometry.fromPolygonXY(
            [[QgsPointXY(x1, y1), QgsPointXY(x2, y2), QgsPointXY(x3, y3),
              QgsPointXY(x4, y4)]])

        feat.setAttributes([i, classe, classe_id, score])
        feat_p.setAttributes([i, classe, classe_id, score])

        geom_p = geom.centroid()
        feat.setGeometry(geom)
        feat_p.setGeometry(geom_p)
        self.pr.addFeatures([feat])
        self.pr_p.addFeatures([feat_p])
        self.polygon.updateExtents()
        self.point.updateExtents()

        self.polygon.updateFields()
        self.polygon.commitChanges()
        self.polygon.startEditing()
        self.point.updateFields()
        self.point.commitChanges()
        self.point.startEditing()
    def create_tables(self,db):
        conn = sqlite3.connect(db)
        c = conn.cursor()
        c.execute('PRAGMA journal_mode=wal')
        c.execute("""CREATE TABLE IF NOT EXISTS data_proc(
                                          id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                                          proc_id integer NOT NULL,
                                          folder text,
                                          image text,
                                          status text,
                                          process integer,
                                          date datetime,
                                          FOREIGN KEY(proc_id) REFERENCES procs(id))""")
        c.execute("""CREATE TABLE IF NOT EXISTS procs(
                                             id INTEGER PRIMARY KEY AUTOINCREMENT NOT NULL,
                                             date_start datetime,
                                             date_finish datetime,
                                             status text,
                                             process integer,
                                             user text)""")
        c.close()
        conn.close()

    def saveproject(self):
        qwidget = QWidget()
        savedirname, _ = QFileDialog.getSaveFileName(
            qwidget, "Save project", "", " SQLite (*.sqlite)")
        if savedirname:
            self.create_tables(savedirname)
        self.db = savedirname

    def openproject(self):
        qfd = QFileDialog()
        filter = "SQLite (*.sqlite)"
        openeddirname = QFileDialog.getOpenFileName(qfd, "Open project", "", filter)[0]

        if openeddirname:
            self.create_tables(openeddirname)
        self.db = openeddirname
        self.dlg.label_sqlite.setText(os.path.basename(self.db))

        self.dlg_monitorate = QDialog()
        self.dlg_monitorate.setWindowTitle(os.path.basename(self.db))
        self.layout_mon = QGridLayout()
        self.pb_mon_proc = QPushButton(text='Processar')
        self.pb_mon_proc.pressed.connect(self.mon_proc)
        self.pb_mon_mon = QPushButton(text='Monitorar')
        self.pb_mon_mon.pressed.connect(self.mon_mon)
        self.layout_mon.addWidget(self.pb_mon_proc,0,0)
        self.layout_mon.addWidget(self.pb_mon_mon,0,1)
        self.dlg_monitorate.setLayout(self.layout_mon)
        self.dlg_monitorate.show()

    def mon_proc(self):
        self.dlg.label_monitorar.setText("PROCESSANDO:")
        self.dlg_monitorate.close()
    def mon_mon(self):
        self.dlg.label_monitorar.setText("MONITORANDO:")
        self.dlg_monitorate.close()
        self.settimer_mon()

    def settimer_mon(self):
        self.timer_mon = QTimer()
        self.timer_mon.setInterval(5000)
        self.timer_mon.timeout.connect(self.update_mon)
        self.timer_mon.start()
    def setouttimer_mon(self):
        self.timer_mon.stop()
    def update_mon(self):
        #get metrics
        #print("update mon")
        conn = sqlite3.connect(self.db)
        c = conn.cursor()
        c.row_factory = sqlite3.Row
        c.execute("""SELECT a.* FROM data_proc a
                     JOIN procs b
                     ON a.proc_id = b.id
                     WHERE b.id = (SELECT max(id) FROM procs)""")
        conn.commit()
        data = c.fetchall()

        self.dlg.table.setRowCount(0)
        for row in data:
            #print(row['proc_id'])
            id = row['id']
            proc_id = row['proc_id']
            folder = row['folder']
            image = row['image']
            status = row['status']
            process = row['process']

            row = self.dlg.table.rowCount()

            color_pend = QColor()
            color_pend.setRgb(89, 141, 214)
            icon_pend = QIcon()
            icon_pend.addPixmap(QPixmap(os.path.join(self.plugin_dir, "icons", "pend.png")), QIcon.Normal, QIcon.Off)

            color_finished = QColor()
            color_finished.setRgb(38, 230, 73)
            icon_finished = QIcon()
            icon_finished.addPixmap(QPixmap(os.path.join(self.plugin_dir, "icons", "finished.png")), QIcon.Normal, QIcon.Off)

            color_problem = QColor()
            color_problem.setRgb(237, 128, 138)
            icon_problem = QIcon()
            icon_problem.addPixmap(QPixmap(os.path.join(self.plugin_dir, "icons", "problem.png")), QIcon.Normal,QIcon.Off)


            item_id = QTableWidgetItem()
            item_id.setCheckState(2)
            item_id.setText(str(id))

            item_img_dir = QTableWidgetItem()
            item_img_dir.setText(str(folder))

            item_img = QTableWidgetItem()
            item_img.setText(str(image))

            item_status = QTableWidgetItem()
            item_status.setText(str(status))
            item_proc = QTableWidgetItem()
            item_proc.setText(str(process))

            if process:
                if process<100:
                    item_status.setIcon(icon_pend)
                    item_status.setBackground(color_pend)
                else:
                    item_status.setIcon(icon_finished)
                    item_status.setBackground(color_finished)
            else:
                item_status.setIcon(icon_pend)
                item_status.setBackground(color_pend)

            self.dlg.table.insertRow(row)
            self.dlg.table.setItem(row, 0, item_id) #id
            self.dlg.table.setItem(row, 1, item_img_dir) #pasta
            self.dlg.table.setItem(row, 2, item_img) #imagem
            self.dlg.table.setItem(row, 3, item_status) #status
            if process:
                self.progressbar = QProgressBar()
                self.progressbar.setValue(process)
                self.dlg.table.setCellWidget(row, 4, self.progressbar)
            else:
                self.progressbar = QProgressBar()
                self.progressbar.setValue(0)
                self.dlg.table.setCellWidget(row, 4, self.progressbar)



        #conn.close()
        #c.close()
        c.execute(f"""SELECT process FROM procs
                     WHERE id = {proc_id}""")
        conn.commit()
        data = c.fetchall()
        for row in data:
            process = row['process']
        if process:
            self.dlg.gcbar_geral.setValue(int(process))

    def setmemoryoutput(self):
        if self.dlg.cb_memory.isChecked():
            self.dlg.ln_output.setText("[Memory Output]")
            self.dlg.pb_salvar.setEnabled(False)
        else:
            self.dlg.pb_salvar.setEnabled(True)
            if len(self.dlg.line_file.displayText())>0:
                if self.dlg.ln_output.displayText()=='[Memory Output]':
                    self.dlg.ln_output.setText("")
                else:
                    return
            else:
                self.dlg.ln_output.setText("")


    def setoutput(self):
        qwidget = QWidget()
        savedirname, _ = QFileDialog.getSaveFileName(
            qwidget, "Save Poligon/Points Shape", "", " Shapefile (*.shp)")
        if savedirname:
            print("caminho de saida obtido")
            self.dlg.ln_output.setText(savedirname)

    def savesqliteproc(self):
        if os.name == 'posix':  # Sistema Unix/Linux
            username = os.getenv('USER')
        elif os.name == 'nt':  # Windows
            username = os.getenv('USERNAME')
        else:
            username = None
        data_hora_atual = datetime.now()
        conn = sqlite3.connect(self.db)
        c = conn.cursor()
        c.execute('PRAGMA journal_mode=wal')
        c.execute(f"""INSERT INTO procs(date_start,date_finish,status,process,user)
                     VALUES('{data_hora_atual}',null,'PEND',0,'{username}')
                     RETURNING id""")
        self.id_proc = c.fetchone()[0]
        print("id_proc: ",self.id_proc)
        conn.commit()
        c.close()
        conn.close()

    def insertsqlitedata(self, id_proc):

        data_hora_atual = datetime.now()
        conn = sqlite3.connect(self.db)
        c = conn.cursor()

        for row in range(0, self.dlg.table.rowCount()):
            image = self.dlg.table.item(row, 2).text()
            folder = self.dlg.table.item(row, 1).text()
            status = self.dlg.table.item(row,3).text()

            c.execute('PRAGMA journal_mode=wal')
            c.execute(f"""INSERT INTO data_proc(proc_id,folder,image,date,status,process)
                         VALUES({id_proc},'{folder}','{image}','{data_hora_atual}','{status}',null)""")

        conn.commit()
        c.close()
        conn.close()

    def getboxes(self):
        if self.dlg.table.rowCount()>0:
            # Crie listas para armazenar diretórios e nomes de arquivos
            diretorios = []
            nomes_arquivos = []

            # Percorra as linhas do QTableWidget
            for row in range(self.dlg.table.rowCount()):
                diretorio = self.dlg.table.item(row, 1)  # Coluna "folder"
                nome_arquivo = self.dlg.table.item(row, 2)  # Coluna "image"

                # Verifique se há diretório e nome de arquivo válidos
                if diretorio and nome_arquivo:
                    diretorios.append(diretorio.text())
                    nomes_arquivos.append(nome_arquivo.text())

            raster1 = gdal.Open(os.path.join(diretorios[0], nomes_arquivos[0]), gdal.GA_ReadOnly)
            proj = osr.SpatialReference(wkt=raster1.GetProjection())
            crs_raster = int(proj.GetAttrValue('AUTHORITY', 1))

            camada_vetorial = QgsVectorLayer('Polygon?crs=epsg:{}&index=yes'.format(crs_raster), "extensao_rasters",
                                             "memory")
            camada_vetorial.startEditing()

            pr = camada_vetorial.dataProvider()
            pr.addAttributes([QgsField("Imagem", QVariant.String)])

            # Verifique se há pelo menos um arquivo válido
            if diretorios and nomes_arquivos:

                # Percorra os diretórios e nomes de arquivos e crie polígonos para cada extensão
                for diretorio, nome_arquivo in zip(diretorios, nomes_arquivos):
                    raster = QgsRasterLayer(os.path.join(diretorio,nome_arquivo))
                    ext = raster.extent()
                    #print(ext)

                    extensao = QgsGeometry.fromRect(ext)
                    #print(extensao)
                    # Adicione o polígono à camada vetorial
                    feature = QgsFeature()
                    feature.setGeometry(extensao)
                    feature.setAttributes([nome_arquivo.replace(".tif","")])
                    #camada_vetorial.addFeature(feature)
                    pr.addFeatures([feature])
                    camada_vetorial.updateExtents()
                    #print(feature)

                camada_vetorial.commitChanges()

                # Adicione a camada vetorial à área de trabalho do QGIS
                QgsProject.instance().addMapLayer(camada_vetorial)

    def get_modelo(self):
        qfd = QFileDialog()
        filter = "Pytorch (*.pt)"
        openeddirname = QFileDialog.getOpenFileName(qfd, "Open project", "", filter)[0]
        self.dlg.line_modelo.setText(openeddirname)
        print(openeddirname)

    def CloseEvent(self, event):
        print("closed")
        try:
            self.setouttimer_mon()
        except:
            pass
    def run(self):
        self.dlg = AIINFDialog()
        self.dlg.pb_inference.clicked.connect(self.setworker)
        #self.dlg.pb_dir_file.clicked.connect(self.dir_file)
        self.dlg.pb_dir_folder.clicked.connect(self.dir_folder)
        self.dlg.pb_modelo.clicked.connect(self.get_modelo)
        self.dlg.cb_confidence.setCurrentText('0.80')
        self.file_folder_status = None
        # show the dialog
        self.dlg.show()
        #self.dlg.actionSalvar.triggered.connect(self.saveproject)
        self.dlg.pb_criar_projeto.clicked.connect(self.saveproject)
        #self.dlg.actionAbrir.triggered.connect(self.openproject)
        self.dlg.pb_abrir_projeto.clicked.connect(self.openproject)
        self.dlg.actionBoxes.triggered.connect(self.getboxes)
        self.dlg.cb_memory.toggled.connect(self.setmemoryoutput)
        self.dlg.pb_salvar.clicked.connect(self.setoutput)
        self.dlg.closeEvent = self.CloseEvent
